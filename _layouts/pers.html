<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>N-point Perspective Grid — Linear & Curvilinear (n ≤ 10)</title>
<style>
  :root{
    --bg:#0b0d10; --panel:#0f1318; --ink:#e8e8e8; --muted:#97a0ad;
    --line:#161a20; --frame:#2a3140; --accent:#66a6ff;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  header{position:sticky;top:0;z-index:4;padding:12px 16px;border-bottom:1px solid #161a20;background:var(--panel)}
  h1{margin:0 0 8px 0;font-size:18px;font-weight:600}
  .controls{display:flex;flex-wrap:wrap;gap:12px;align-items:center;font-size:14px}
  .control{display:flex;gap:8px;align-items:center;background:#0b0f14;border:1px solid #1b1f24;border-radius:12px;padding:8px 10px}
  .control label{color:var(--muted)}
  input[type="range"]{width:180px}
  input[type="number"]{width:90px;background:#0b0f14;color:var(--ink);border:1px solid #1b1f24;border-radius:8px;padding:4px 6px}
  button,select{background:#11161d;color:var(--ink);border:1px solid #1b1f24;border-radius:10px;padding:6px 10px;cursor:pointer}
  button:hover{border-color:#2a3140}
  #wrap{position:relative}
  #canvas{display:block;width:100vw;height:calc(100vh - 110px)}
  .hint{position:absolute;left:12px;bottom:10px;color:var(--muted);font-size:12px;background:#0b0f14a0;padding:6px 8px;border-radius:8px;border:1px solid #1b1f24}
</style>
</head>
<body>
<header>
  <h1>N-point Perspective Grid — Linear & Curvilinear (n ≤ 10)</h1>
  <div class="controls">
    <div class="control">
      <label for="mode">mode</label>
      <select id="mode">
        <option value="linear">linear</option>
        <option value="curvi">curvilinear (equidistant fisheye)</option>
      </select>
    </div>
    <div class="control">
      <label for="n">n</label>
      <input id="n" type="range" min="1" max="10" value="3" />
      <span id="nval">3</span>
    </div>
    <div class="control">
      <label for="linesPerVP">lines/VP</label>
      <input id="linesPerVP" type="number" min="4" max="120" step="1" value="24" />
    </div>
    <div class="control">
      <label for="layout">init</label>
      <select id="layout">
        <option value="circle">circle</option>
        <option value="horizon">horizon line</option>
        <option value="random">random ring</option>
      </select>
      <button id="reset">reset</button>
    </div>
    <div class="control">
      <label for="base">transversal</label>
      <select id="base">
        <option value="bottom">bottom / lat −45°</option>
        <option value="top">top / lat +45°</option>
        <option value="left">left / meridian −90°</option>
        <option value="right">right / meridian +90°</option>
        <option value="centerH">center (equator)</option>
        <option value="centerV">center (meridian 0°)</option>
      </select>
    </div>
    <div class="control" id="curviBox">
      <label for="fov">FOV</label>
      <input id="fov" type="range" min="100" max="180" step="5" value="160" />
      <span id="fovval">160°</span>
      <label><input type="checkbox" id="showFOV" checked /> show FOV</label>
    </div>
    <div class="control">
      <label for="alpha">opacity</label>
      <input id="alpha" type="range" min="0.05" max="1" step="0.05" value="0.35" />
      <span id="alphaval">0.35</span>
    </div>
    <div class="control">
      <button id="addVP">+ VP</button>
      <button id="removeVP">− VP</button>
      <button id="save">save JSON</button>
      <button id="load">load JSON</button>
    </div>
  </div>
</header>

<div id="wrap">
  <canvas id="canvas"></canvas>
  <div class="hint">Drag VP • Shift=grid-snap • Double-click = add VP • Touch drag supported</div>
</div>

<script>
(() => {
  // ---------- DOM refs ----------
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const elMode = document.getElementById('mode');
  const elN = document.getElementById('n');
  const elNVal = document.getElementById('nval');
  const elLines = document.getElementById('linesPerVP');
  const elLayout = document.getElementById('layout');
  const elReset = document.getElementById('reset');
  const elBase = document.getElementById('base');
  const elAlpha = document.getElementById('alpha');
  const elAlphaVal = document.getElementById('alphaval');
  const elAdd = document.getElementById('addVP');
  const elRemove = document.getElementById('removeVP');
  const elSave = document.getElementById('save');
  const elLoad = document.getElementById('load');
  const elFOV = document.getElementById('fov');
  const elFOVVal = document.getElementById('fovval');
  const elShowFOV = document.getElementById('showFOV');
  const curviBox = document.getElementById('curviBox');

  // ---------- State ----------
  const state = {
    mode: elMode.value, // 'linear' | 'curvi'
    n: parseInt(elN.value,10),
    linesPerVP: parseInt(elLines.value,10),
    base: elBase.value,
    alpha: parseFloat(elAlpha.value),
    fovDeg: parseInt(elFOV.value,10), // for curvi
    showFOV: elShowFOV.checked,
    vps: [], // { x,y, dir:[x,y,z] }
    dragIdx: -1,
  };

  // ---------- Utils ----------
  const TAU = Math.PI*2;
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(canvas.clientWidth*dpr);
    canvas.height= Math.floor(canvas.clientHeight*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }
  window.addEventListener('resize', resize, {passive:true});

  function ringLayout(n){
    const w=canvas.clientWidth, h=canvas.clientHeight; const cx=w/2, cy=h/2; const R=Math.max(w,h)*0.6;
    const arr=[]; for(let i=0;i<n;i++){ const t=i/n*TAU; arr.push({x:cx+R*Math.cos(t), y:cy+R*Math.sin(t)}); }
    return arr;
  }
  function horizonLayout(n){
    const w=canvas.clientWidth, h=canvas.clientHeight; const y=h*0.35; const arr=[];
    for(let i=0;i<n;i++){ const t=(n===1)?0.5:i/(n-1); const x=-w*0.2 + t*(w*1.4); arr.push({x,y}); }
    return arr;
  }
  function randomRingLayout(n){
    const w=canvas.clientWidth, h=canvas.clientHeight; const cx=w/2, cy=h/2; const R=Math.max(w,h)*0.6;
    const arr=[]; for(let i=0;i<n;i++){ const t=Math.random()*TAU; const r=R*(0.85+0.3*Math.random()); arr.push({x:cx+r*Math.cos(t), y:cy+r*Math.sin(t)}); }
    return arr;
  }

  function initVPs(n, mode){
    const lay = (elLayout.value==='circle')? ringLayout(n) : (elLayout.value==='horizon'? horizonLayout(n): randomRingLayout(n));
    state.vps = [];
    for(let i=0;i<n;i++){
      const vp = { x: lay[i].x, y: lay[i].y, dir: null };
      state.vps.push(vp);
    }
    // If curvi, also seed spherical directions from screen positions
    if (mode==='curvi') syncToCurvi();
  }

  // ---------- Linear helpers ----------
  function lineRectIntersections(x1,y1,x2,y2,w,h){
    const pts=[]; const dx=x2-x1, dy=y2-y1; const eps=1e-9;
    function add(x,y){ if(x>=-1e-6 && x<=w+1e-6 && y>=-1e-6 && y<=h+1e-6) pts.push({x,y}); }
    if (Math.abs(dx)>eps){ let t=(0-x1)/dx; add(x1+t*dx,y1+t*dy); t=(w-x1)/dx; add(x1+t*dx,y1+t*dy); }
    if (Math.abs(dy)>eps){ let t=(0-y1)/dy; add(x1+t*dx,y1+t*dy); t=(h-y1)/dy; add(x1+t*dx,y1+t*dy); }
    if (pts.length<2) return pts;
    // choose farthest two
    let bi=0,bj=1,bd=-1; for(let i=0;i<pts.length;i++){ for(let j=i+1;j<pts.length;j++){ const d=(pts[i].x-pts[j].x)**2+(pts[i].y-pts[j].y)**2; if(d>bd){bd=d;bi=i;bj=j;} }}
    return [pts[bi],pts[bj]];
  }
  function basePointsLinear(count, mode){
    const w=canvas.clientWidth, h=canvas.clientHeight; const m=24; const res=[];
    if (mode==='bottom'||mode==='top'){
      const y = (mode==='bottom')? (h-m):(m);
      for(let i=0;i<count;i++){ const t=(count===1)?0.5:i/(count-1); res.push({x:m+t*(w-2*m), y}); }
    } else if (mode==='left'||mode==='right'){
      const x = (mode==='left')? (m):(w-m);
      for(let i=0;i<count;i++){ const t=(count===1)?0.5:i/(count-1); res.push({x, y:m+t*(h-2*m)}); }
    } else if (mode==='centerH'){
      const y=h/2; for(let i=0;i<count;i++){ const t=(count===1)?0.5:i/(count-1); res.push({x:24+t*(w-48), y}); }
    } else { // centerV
      const x=w/2; for(let i=0;i<count;i++){ const t=(count===1)?0.5:i/(count-1); res.push({x, y:24+t*(h-48)}); }
    }
    return res;
  }

  // ---------- Curvilinear (equidistant fisheye) ----------
  // Camera center looks along +Z; image plane is (x,y), center at (cx,cy).
  function fovToFocalPx(fovDeg, radiusPx){ // equidistant: r = f*theta; theta_max = fov/2 -> f = R / theta_max
    const thetaMax = (fovDeg*Math.PI/180)/2; return radiusPx / thetaMax;
  }
  function dirToScreen(d, cx, cy, f, radiusPx){
    // d: unit vec (x,y,z). Equidistant: r = f*theta, theta = arccos(z)
    const z = clamp(d[2], -1, 1);
    const theta = Math.acos(z); // [0, pi]
    const r = f*theta; if (r>radiusPx+1) return null; // outside FOV circle
    const s = Math.hypot(d[0], d[1]);
    let u=[0,0]; if (s<1e-9){ u=[0,0]; } else { u=[d[0]/s, d[1]/s]; }
    const x = cx + r*u[0];
    const y = cy - r*u[1];
    return {x,y};
  }
  function screenToDir(x, y, cx, cy, f){
    const dx = x - cx; const dy = -(y - cy); const r = Math.hypot(dx,dy);
    if (r<1e-9) return [0,0,1];
    const theta = r / f; // equidistant inverse
    const u = [dx/r, dy/r];
    const st = Math.sin(theta), ct = Math.cos(theta);
    return [st*u[0], st*u[1], ct]; // already unit
  }
  function greatCirclePoint(a, b, t){ // a,b: unit vecs; t∈[0,1]
    const dot = clamp(a[0]*b[0] + a[1]*b[1] + a[2]*b[2], -1, 1);
    const w = Math.acos(dot);
    if (w<1e-8){ return a.slice(); }
    const s1 = Math.sin((1-t)*w)/Math.sin(w);
    const s2 = Math.sin(t*w)/Math.sin(w);
    return [ s1*a[0]+s2*b[0], s1*a[1]+s2*b[1], s1*a[2]+s2*b[2] ];
  }
  function baseDirsCurvi(count, mode){
    // Equator/latitudes/meridians, centered at +Z
    const res=[]; const lat45 = Math.PI/4;
    if (mode==='centerH'){ // equator (lat 0)
      for(let i=0;i<count;i++){ const t=(count===1)?0.5:i/(count-1); const phi=t*TAU; res.push([Math.cos(phi), Math.sin(phi), 0]); }
    } else if (mode==='top'||mode==='bottom'){ // latitude ±45°
      const lat = (mode==='top')? +lat45 : -lat45; const cz=Math.sin(lat), r=Math.cos(lat);
      for(let i=0;i<count;i++){ const t=(count===1)?0.5:i/(count-1); const phi=t*TAU; res.push([r*Math.cos(phi), r*Math.sin(phi), cz]); }
    } else if (mode==='left' || mode==='right' || mode==='centerV'){
      // meridians at φ = -90°, +90°, 0° respectively; sweep lat from -80°..+80°
      const phi = (mode==='left')? -Math.PI/2 : (mode==='right')? +Math.PI/2 : 0;
      for(let i=0;i<count;i++){
        const t=(count===1)?0.5:i/(count-1); const lat = (-0.8+1.6*t)*Math.PI/2; // [-72°, +72°]
        const cz=Math.sin(lat), r=Math.cos(lat);
        res.push([r*Math.cos(phi), r*Math.sin(phi), cz]);
      }
    }
    return res;
  }
  function syncToCurvi(){ // ensure VP.dir exists from VP.x,y
    const w=canvas.clientWidth, h=canvas.clientHeight; const cx=w/2, cy=h/2; const R=Math.min(w,h)/2; const f=fovToFocalPx(state.fovDeg, R);
    for(const vp of state.vps){
      if (!vp.dir){ vp.dir = screenToDir(vp.x??(cx), vp.y??(cy), cx, cy, f); }
    }
  }
  function syncToLinear(){ // ensure VP.x,y from VP.dir
    const w=canvas.clientWidth, h=canvas.clientHeight; const cx=w/2, cy=h/2; const R=Math.min(w,h)/2; const f=fovToFocalPx(state.fovDeg, R);
    const fallback = ringLayout(state.vps.length);
    for(let i=0;i<state.vps.length;i++){
      const vp = state.vps[i];
      if (vp.x==null || vp.y==null){
        if (vp.dir){ const p = dirToScreen(vp.dir, cx, cy, f, R); if (p){ vp.x=p.x; vp.y=p.y; continue; } }
        // fallback
        vp.x = fallback[i].x; vp.y=fallback[i].y;
      }
    }
  }

  // ---------- Drawing ----------
  function drawLinear(){
    const w=canvas.clientWidth, h=canvas.clientHeight;
    // bg + subtle grid
    ctx.clearRect(0,0,w,h); ctx.fillStyle= getComputedStyle(document.body).getPropertyValue('--bg'); ctx.fillRect(0,0,w,h);
    ctx.lineWidth=1; ctx.strokeStyle='#151a20';
    for(let x=0;x<=w; x+=40){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
    for(let y=0;y<=h; y+=40){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }

    const pts = basePointsLinear(state.linesPerVP, state.base);
    ctx.globalAlpha = state.alpha;
    for (let i=0;i<state.vps.length;i++){
      const vp = state.vps[i];
      const hue = Math.floor((i*137.508)%360); ctx.strokeStyle = `hsl(${hue} 70% 60%)`;
      for (const p of pts){
        const is = lineRectIntersections(vp.x, vp.y, p.x, p.y, w, h);
        if (is.length===2){ ctx.beginPath(); ctx.moveTo(is[0].x, is[0].y); ctx.lineTo(is[1].x, is[1].y); ctx.stroke(); }
      }
    }
    ctx.globalAlpha=1;

    // draw base line
    ctx.lineWidth=1.5; ctx.strokeStyle=getComputedStyle(document.body).getPropertyValue('--frame');
    const bps=basePointsLinear(2, state.base);
    if (bps.length===2){ ctx.beginPath(); ctx.moveTo(bps[0].x, bps[0].y); ctx.lineTo(bps[1].x, bps[1].y); ctx.stroke(); }

    // draw VPs
    for(let i=0;i<state.vps.length;i++){
      const vp=state.vps[i];
      ctx.fillStyle='#0b0d10'; ctx.strokeStyle='white'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(vp.x, vp.y, 6, 0, TAU); ctx.fill(); ctx.stroke();
      ctx.fillStyle='white'; ctx.font='12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace'; ctx.fillText(`VP${i+1}`, vp.x+8, vp.y-8);
    }

    // frame
    ctx.strokeStyle='#2a3140'; ctx.lineWidth=2; ctx.strokeRect(0.5,0.5,w-1,h-1);
  }

  function drawCurvi(){
    const w=canvas.clientWidth, h=canvas.clientHeight; const cx=w/2, cy=h/2; const R=Math.min(w,h)/2; const f=fovToFocalPx(state.fovDeg, R);

    // bg + polar grid
    ctx.clearRect(0,0,w,h); ctx.fillStyle= getComputedStyle(document.body).getPropertyValue('--bg'); ctx.fillRect(0,0,w,h);
    ctx.lineWidth=1; ctx.strokeStyle='#151a20';
    // faint concentric circles every ~20° in theta
    for(let deg=20; deg<state.fovDeg/2*2; deg+=20){
      const r = f * (deg*Math.PI/180);
      if (r<R-1){ ctx.beginPath(); ctx.arc(cx,cy,r,0,TAU); ctx.stroke(); }
    }
    // cross axes
    ctx.beginPath(); ctx.moveTo(cx-R, cy); ctx.lineTo(cx+R, cy); ctx.moveTo(cx, cy-R); ctx.lineTo(cx, cy+R); ctx.stroke();

    // draw FOV circle
    if (state.showFOV){ ctx.strokeStyle='#2a3140'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(cx,cy,R-0.5,0,TAU); ctx.stroke(); }

    // base directions on sphere
    const baseDirs = baseDirsCurvi(state.linesPerVP, state.base);

    ctx.globalAlpha = state.alpha;
    for(let i=0;i<state.vps.length;i++){
      const vp = state.vps[i];
      const hue = Math.floor((i*137.508)%360); ctx.strokeStyle=`hsl(${hue} 70% 60%)`;
      for(const a of baseDirs){
        // draw geodesic from a to vp.dir
        const steps = 120; ctx.beginPath(); let started=false;
        for(let s=0;s<=steps;s++){
          const t = s/steps; const d = greatCirclePoint(a, vp.dir, t);
          const p = dirToScreen(d, cx, cy, f, R);
          if (!p){ started=false; continue; }
          if (!started){ ctx.moveTo(p.x,p.y); started=true; } else { ctx.lineTo(p.x,p.y); }
        }
        ctx.stroke();
      }
    }
    ctx.globalAlpha = 1;

    // draw VPs as screen-projected dots
    for(let i=0;i<state.vps.length;i++){
      const vp=state.vps[i]; const p = dirToScreen(vp.dir, cx, cy, f, R);
      if (!p) continue;
      ctx.fillStyle='#0b0d10'; ctx.strokeStyle='white'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, TAU); ctx.fill(); ctx.stroke();
      ctx.fillStyle='white'; ctx.font='12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace'; ctx.fillText(`VP${i+1}`, p.x+8, p.y-8);
    }

    // frame rectangle (optional)
    ctx.strokeStyle='#2a3140'; ctx.lineWidth=2; ctx.strokeRect(0.5,0.5,w-1,h-1);
  }

  function draw(){
    if (state.mode==='linear'){ syncToLinear(); drawLinear(); }
    else { syncToCurvi(); drawCurvi(); }
  }

  // ---------- Interactions ----------
  function pickVP_linear(mx,my){
    const r2=100; let idx=-1, best=1e9; for(let i=0;i<state.vps.length;i++){ const vp=state.vps[i]; const dx=vp.x-mx, dy=vp.y-my; const d2=dx*dx+dy*dy; if(d2<best && d2<=r2){best=d2; idx=i;} } return idx;
  }
  function pickVP_curvi(mx,my){
    // pick closest by screen-projected dot
    const w=canvas.clientWidth, h=canvas.clientHeight; const cx=w/2, cy=h/2; const R=Math.min(w,h)/2; const f=fovToFocalPx(state.fovDeg, R);
    let idx=-1, best=1e9; for(let i=0;i<state.vps.length;i++){ const p=dirToScreen(state.vps[i].dir, cx, cy, f, R); if(!p) continue; const dx=p.x-mx, dy=p.y-my; const d2=dx*dx+dy*dy; if(d2<best && d2<=100){best=d2; idx=i;} } return idx;
  }
  function onDown(clientX, clientY){
    const rect=canvas.getBoundingClientRect(); const mx=clientX-rect.left, my=clientY-rect.top;
    state.dragIdx = (state.mode==='linear')? pickVP_linear(mx,my) : pickVP_curvi(mx,my);
  }
  function onMove(clientX, clientY, shiftKey){
    if (state.dragIdx<0) return; const rect=canvas.getBoundingClientRect(); let mx=clientX-rect.left, my=clientY-rect.top;
    if (shiftKey){ const snap=10; mx=Math.round(mx/snap)*snap; my=Math.round(my/snap)*snap; }
    const vp = state.vps[state.dragIdx];
    if (state.mode==='linear'){
      vp.x=mx; vp.y=my; // update proxy dir for smoother switch
      const w=canvas.clientWidth, h=canvas.clientHeight; const cx=w/2, cy=h/2; const R=Math.min(w,h)/2; const f=fovToFocalPx(state.fovDeg, R);
      vp.dir = screenToDir(mx,my,cx,cy,f);
    } else {
      // update dir by inverse mapping; keep x,y as last known projection
      const w=canvas.clientWidth, h=canvas.clientHeight; const cx=w/2, cy=h/2; const R=Math.min(w,h)/2; const f=fovToFocalPx(state.fovDeg, R);
      vp.dir = screenToDir(mx,my,cx,cy,f);
      const p = dirToScreen(vp.dir,cx,cy,f,R); if(p){ vp.x=p.x; vp.y=p.y; }
    }
    draw();
  }
  function onUp(){ state.dragIdx=-1; }

  canvas.addEventListener('mousedown', e=> onDown(e.clientX, e.clientY));
  window.addEventListener('mousemove', e=> onMove(e.clientX, e.clientY, e.shiftKey));
  window.addEventListener('mouseup', onUp);
  // touch
  canvas.addEventListener('touchstart', e=>{ if(e.touches.length){ const t=e.touches[0]; onDown(t.clientX,t.clientY); }},{passive:true});
  window.addEventListener('touchmove', e=>{ if(e.touches.length){ const t=e.touches[0]; onMove(t.clientX,t.clientY, false); }},{passive:true});
  window.addEventListener('touchend', onUp);

  canvas.addEventListener('dblclick', (e)=>{
    const rect=canvas.getBoundingClientRect(); const mx=e.clientX-rect.left, my=e.clientY-rect.top;
    if (state.vps.length>=10) return;
    const w=canvas.clientWidth, h=canvas.clientHeight; const cx=w/2, cy=h/2; const R=Math.min(w,h)/2; const f=fovToFocalPx(state.fovDeg, R);
    const dir = screenToDir(mx,my,cx,cy,f);
    state.vps.push({ x:mx, y:my, dir });
    elN.value = state.vps.length; elNVal.textContent = elN.value;
    draw();
  });

  // ---------- UI hooks ----------
  elMode.addEventListener('change', ()=>{ state.mode=elMode.value; curviBox.style.display = (state.mode==='curvi')?'flex':'none'; draw(); });
  elN.addEventListener('input', ()=>{
    const newN=parseInt(elN.value,10); elNVal.textContent=newN; const cur=state.vps.length;
    if (newN>cur){ const more = ringLayout(newN).slice(cur); for(const p of more){ state.vps.push({x:p.x,y:p.y,dir:null}); }
      if (state.mode==='curvi') syncToCurvi();
    } else if (newN<cur){ state.vps.length=newN; }
    draw();
  });
  elLines.addEventListener('change', ()=>{ state.linesPerVP=clamp(parseInt(elLines.value,10)||24,4,120); elLines.value=state.linesPerVP; draw(); });
  elBase.addEventListener('change', ()=>{ state.base=elBase.value; draw(); });
  elAlpha.addEventListener('input', ()=>{ state.alpha=parseFloat(elAlpha.value); elAlphaVal.textContent=state.alpha.toFixed(2); draw(); });
  elReset.addEventListener('click', ()=>{ initVPs(state.vps.length, state.mode); draw(); });
  elAdd.addEventListener('click', ()=>{ if(state.vps.length>=10) return; const w=canvas.clientWidth,h=canvas.clientHeight; const cx=w/2, cy=h/2; const R=Math.min(w,h)/2; const f=fovToFocalPx(state.fovDeg, R); const x=cx, y=cy; const dir=screenToDir(x,y,cx,cy,f); state.vps.push({x,y,dir}); elN.value=state.vps.length; elNVal.textContent=elN.value; draw(); });
  elRemove.addEventListener('click', ()=>{ if(state.vps.length<=1) return; state.vps.pop(); elN.value=state.vps.length; elNVal.textContent=elN.value; draw(); });
  elFOV.addEventListener('input', ()=>{ state.fovDeg=parseInt(elFOV.value,10); elFOVVal.textContent=state.fovDeg+"°"; draw(); });
  elShowFOV.addEventListener('change', ()=>{ state.showFOV=elShowFOV.checked; draw(); });

  elSave.addEventListener('click', ()=>{
    const payload = { version:2, mode:state.mode, n:state.vps.length, linesPerVP:state.linesPerVP, base:state.base, alpha:state.alpha, fovDeg:state.fovDeg, showFOV:state.showFOV, vps: state.vps };
    const blob=new Blob([JSON.stringify(payload,null,2)], {type:'application/json'});
    const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.download='npoint_curvi_config.json'; a.href=url; a.click(); URL.revokeObjectURL(url);
  });
  elLoad.addEventListener('click', ()=>{
    const inp=document.createElement('input'); inp.type='file'; inp.accept='application/json';
    inp.onchange=e=>{
      const file=e.target.files[0]; if(!file) return; const fr=new FileReader();
      fr.onload=()=>{ try{ const obj=JSON.parse(fr.result);
        if(Array.isArray(obj.vps) && obj.vps.length>=1 && obj.vps.length<=10){
          state.mode = obj.mode||state.mode; elMode.value=state.mode; curviBox.style.display = (state.mode==='curvi')?'flex':'none';
          state.vps = obj.vps.map(o=>({ x:(o.x!=null?+o.x:null), y:(o.y!=null?+o.y:null), dir:(Array.isArray(o.dir)? [ +o.dir[0], +o.dir[1], +o.dir[2] ] : null) }));
          state.linesPerVP = +obj.linesPerVP || state.linesPerVP; elLines.value=state.linesPerVP;
          state.base = obj.base || state.base; elBase.value=state.base;
          state.alpha = +obj.alpha || state.alpha; elAlpha.value=state.alpha; elAlphaVal.textContent=state.alpha.toFixed(2);
          state.fovDeg = +obj.fovDeg || state.fovDeg; elFOV.value=state.fovDeg; elFOVVal.textContent=state.fovDeg+"°";
          state.showFOV = !!obj.showFOV; elShowFOV.checked=state.showFOV;
          elN.value = state.vps.length; elNVal.textContent = elN.value; draw();
        }
      } catch(err){ alert('Invalid JSON'); } };
      fr.readAsText(file);
    }; inp.click();
  });

  // ---------- Boot ----------
  function boot(){ resize(); initVPs(state.n, state.mode); draw(); }
  boot();
})();
</script>
</body>
</html>
